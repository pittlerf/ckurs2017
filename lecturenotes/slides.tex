\documentclass[xcolor=dvipsnames]{beamer}

\geometry{paperwidth=140mm,paperheight=105mm}

\input{slidespreamble}

\newcounter{lecturecounter}
\setcounter{lecturecounter}{1}

\author[B. Kostrzewa]{Bartosz Kostrzewa, Ferenc Pittler, Martin Ueding, Carsten Urbach}
\title{C-Kurs Physik, 2017}
\institute[HISKP]{HISKP, Rheinische Friedrich-Wilhelms-Universität Bonn}
% \titlegraphic{\roundbox{\includegraphics[height=2cm]{UniBonn_CRC110_ETMC_INFN}}}
\date[April 2017]{April 2017}

\begin{document}

% \frame{}
\begin{frame}
 \titlepage
\end{frame}

\begin{frame}{Administrativa}
  \begin{itemize}
  \item{Vorlesung 03.04-13.04, 10-12 Uhr, \textbf{PI HS1}}
  \begin{itemize}
    \item{06.04: \textbf{HS HISKP} }
  \end{itemize}
  \vspace{0.2cm}
  \item{Bartosz Kostrzewa, bartosz\_kostrzewa@fastmail.com, Raum 3.009 HISKP}
  \begin{itemize}
    \item{Sprechzeiten: Täglich 17:00-17:45 Uhr}
  \end{itemize}
  \vspace{0.2cm}
  \item{Tutoren}
  \begin{itemize}
    \item{Martin~Ueding, Simon~Schlepphorst, 
         \\Ferenc~Pittler, Marcel~Nitsch, Florian~Tauber} 
  \end{itemize}
  \vspace{0.2cm}
  \item{Tutorien finden statt: täglich 13:00-17:00}
  \begin{itemize}
    \item{Astro CIP Pool (Raum 0.007) [AifA, Auf dem Hügel 71]}
    \item{HISKP SR1 [HISKP, Nußallee 14-16]}
    \begin{itemize}
      \item{\textbf{ $\mathbf{18}$ Personen $\rightarrow$ Astro, $\quad\mathbf{N-18}$ $\rightarrow$ SR1} }
    \end{itemize}
  \end{itemize}
  \vspace{0.2cm}
  \item{Das Skript dient als Referenz und sollte zumindest während der Tutorien befragt werden!}
  \vspace{0.2cm}
  \item{Fundamentale Ungleichung der Programmierung (FUP!): \\ \textbf{Praxis $\mathbf{\gg}$ Vorlesungen} $\rightarrow$ besuchen Sie die Übungen, sonst bringt die Vorlesung nichts!}
  \item{Folien, Übungszettel, Beispielprogramme: \textcolor{blue}{\url{http://goo.gl/xhJN08}}}
  \end{itemize}
\end{frame}

\begin{frame}{Lernziele}
\begin{itemize}
  \item{Algorithmen verstehen und entwickeln}
  \item{Algorithmen in Quelltext übertragen}
  \vspace{0.3cm}
  \item{Erstes Kennenlernen der sogennanten \emph{imperativen} Programmierung}
  \item{Kennenlernen der Daten- und Kontrollstrukturen von C99}
  \vspace{0.3cm}
  \item{Praktischer Einsatz des C-Compilers zur Übersetzung des Quelltextes in ausführbaren Maschinencode}
  \item{Erstellen eigener C-Programme in den Tutorien}
  \begin{itemize}
    \item{einfache Beispielprogramme $\rightarrow$ kompliziertere Programme aus merheren Quelltextdateien}
    \item{Verwendung externer Bilbiotheken}
  \end{itemize}
  \vspace{0.3cm}
  \item{Vorbereitung auf \emph{physik441: Computerphysik} (SoSe 2017), \emph{physics760: Computational Physics} (WiSe 2017/2018), etwaige Bachelor- und Masterarbeiten}
\end{itemize} 
\end{frame}

\begin{frame}{Anwendung: Plasmaphysik / Fusion}
  \centering
  Wellenstein 7-x Stellerator\\ \vspace{0.2cm}
  \includegraphics[width=0.9\textwidth]{graphics/stellerator.jpg}\\
  {\small Quelle: \url{http://www.sciencemag.org/news/2015/10/bizarre-reactor-might-save-nuclear-fusion} }
\end{frame}

\begin{frame}{Anwendung: Kosmologie / Astrophysik}
  \centering
  Simulation der Galaxie M74 über 13 Milliarden Jahre\\ \vspace{0.2cm}
  \includegraphics[width=0.9\textwidth]{graphics/m74_simulation.png}\\
  {\small Quelle: \url{http://www.hpc-ch.org/first-realistic-simulation-of-the-formation-of-the-milky-way-computed-at-cscs/} }  
\end{frame}

\begin{frame}{Anwendung: Hochenergiephysik - LHC}
  \centering
  Kollision im ATLAS-Experiment\\ \vspace{0.2cm}
  \includegraphics[width=0.9\textwidth]{graphics/atlas_event.png}\\
  {\small Quelle: \url{ https://cds.cern.ch/record/2113241 } }
\end{frame}

\begin{frame}{Anwendung: Hochenergiephysik / Gitter-QCD}
  \centering
  Simulation der Quantenchromodynamik auf Hochgeschwindigkeitsrechnern\\ \vspace{0.2cm}
  \begin{columns}
  \column{0.49\textwidth}
    \includegraphics[width=0.8\textwidth]{graphics/LQCD2.jpg} \\
  \column{0.49\textwidth}
    \includegraphics[width=0.8\textwidth]{graphics/juqueen.jpg} \\
  \end{columns}
  \vspace{0.3cm}
  {\small Quellen: \url{http://lpc-clermont.in2p3.fr/IMG/theorie/LQCD2.jpg} \\
                   \url{http://www.fz-juelich.de/ias/jsc/EN/Expertise/Supercomputers/JUQUEEN/JUQUEEN_node.html} }
\end{frame}

\begin{frame}{Anwendung: Biophysik / Biochemie - Molekulardynamik}
  \centering
  Simulation des NMDA Proteins und Rezeptors im menschlichen Gehirn\\ \vspace{0.2cm}
  \includegraphics[width=0.4\textwidth]{graphics/glutamate.jpg}\\
  {\small Quelle: \url{http://computation.llnl.gov/glutamate-receptor-molecular-dynamics-simulation} }
\end{frame}

\begin{frame}{Die Programmiersprache C}{Vorlesung \arabic{lecturecounter}}
  \centering
  \includegraphics[height=7cm]{graphics/The_C_Programming_Language_cover}
\end{frame}

\begin{frame}{Algorithmus: Einfügensortieren Pseudocode}{Vorlesung \arabic{lecturecounter}}
  \include{algos/einfuegensortieren}
\end{frame}

\begin{frame}[fragile]{Die Struktur eines C-Programms}{Vorlesung \arabic{lecturecounter}}
Das einfache Programm
\begin{lstlisting}
#include <stdio.h>
int main(void){
  printf("Hallo, Welt!\n");
  return 0;
}
\end{lstlisting}
können wir in einer Textdatei \verb|hallo_welt.c| abspeichern und mit dem C-Compiler in ein ausführbares Programm übersetzen
\begin{verbatim}
$ gcc -Wall -Wpedantic -std=c99 -o hallo_welt hallo_welt.c
\end{verbatim}
und es dann ausführen
\begin{verbatim}
$ ./hallo_welt
Hallo, Welt!
$ _
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{Variablen deklarieren und definieren}{Vorlesung \arabic{lecturecounter}}
 Eine Variable wird in C mit:
\begin{lstlisting}
DATENTYP NAME;        // deklariert
NAME = WERT;          // definiert
DATENYP NAME = WERT;  // deklariert und definiert
\end{lstlisting}
 \begin{block}{Blöcke und Sichbarkeitsbereich (\emph{scope})}
 In C werden Programmblöcke mit $\lbrace$ und $\rbrace$ umklammert.
 Ein Block fasst mehrere Ausdrücke (\emph{statements}) zu einem Ausdruck zusammen.
 Eine Variablendeklaration gilt innerhalb eines Blocks und seiner Unterblöcke.
 \end{block}
\begin{lstlisting}
DATENTYP1 VAR1 = WERT1;         // Aeusserster Block
{
  DATENTYP2 VAR2 = WERT2;
  // hier gelten sowohl VAR1 als auch VAR2
  {
    DATENTYP3 VAR3 = WERT3;
    // hier gelten alle drei Variablen
  } // ab hier gilt VAR3 nicht mehr
} // jetzt gilt auch VAR2 nicht mehr
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Einrückung und Kommentare}{Vorlesung \arabic{lecturecounter}}
\begin{lstlisting}
DATENTYP1 VAR1 = WERT1;         // Aeusserster Block
{
  DATENTYP2 VAR2 = WERT2;
  // hier gelten sowohl VAR1 als auch VAR2
  {
    DATENTYP3 VAR3 = WERT3;
    // hier gelten alle drei Variablen
  } // ab hier gilt VAR3 nicht mehr
} // jetzt gilt auch VAR2 nicht mehr
\end{lstlisting}
\begin{block}{}
  Ein wichtiger Aspekt, der zur Lesbarkeit eines Quelltextes beiträgt, ist eine konsistente Einrückung der Programmblöcke. Man hätte auch folgendes schreiben können.
\end{block}
\begin{lstlisting}
DATENTYP1 VAR1=WERT1;{DATENTYP2 VAR2=WERT2;{DATENTYP3 VAR3=WERT3;}}
\end{lstlisting}
\begin{block}{}
An nicht-trivialen Stellen des Programmcodes ist es zudem wichtig, dass man Kommentare einfügt, um sich und anderen zu erklären, was da geschieht. 
\end{block}
\end{frame}

\begin{frame}[fragile]{Bedingte Ausführung: \texttt{if / else} Statement}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  Das \texttt{if / else} statement erlaubt es, den Programmfluss abhängig vom momentanen Zustand zu steuern.
\end{block}
Input: $x, y, z$
\begin{lstlisting}
if( x > 0 ){
  // x groesser 0
} else if ( x == 0 && y <= 1 ) {
  // x gleich 0 UND y kleiner-gleich 1
  if( (z + 3) == y ){
    // z+3 gleich y
  }
} else if ( x == 0 && y > 1 ) {
  // x gleich 0 UND y groesser 1
} else if ( x < 0 ) {
  // Falls x kleiner 0
}
if( z > 0 || (y % 2 == 0) ){
  // z groesser 0 ODER y gerade
}
\end{lstlisting}
\textbf{Unter welchen Umständen wird keine Anweisung ausgeführt?}
\end{frame}

\begin{frame}[fragile]{Schleifen: \texttt{while} \& \texttt{do-while} (1/2)}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  Iterative Verfahren sind ein zentraler Bestandteil vieler Algorithmen.
  Schleifen wiederholen Anweisungen, bis eine gewählte Bedingung erreicht ist.
\end{block}
Die \texttt{while}- und \texttt{do-while}-Schleifen sind die einfachsten Schleifentypen in C und haben folgende Struktur:
\vspace{0.2cm}
\begin{columns}
\column{0.49\textwidth}
\begin{lstlisting}
while( LOGISCHER AUSDRUCK ){
  BEFEHLE
}  
\end{lstlisting}
\begin{enumerate}
  \item[(1)]{ \texttt{AUSDRUCK} auf Wahrheit prüfen }
  \begin{itemize}
    \item[wahr]{ \texttt{BEFEHLE} ausführen }
    \begin{itemize}
      \item[$\drsh$]{Zurück zu (1)}
    \end{itemize}
    \item[unwahr]{ Schleife beenden }
  \end{itemize}
\end{enumerate}

\column{0.49\textwidth}
\begin{lstlisting}
do {
  BEFEHLE
} while( LOGISCHER AUSDRUCK ); 
\end{lstlisting}
\begin{enumerate}
  \item[(0)]{ \texttt{BEFEHLE} ausführen }
  \item[(1)]{ \texttt{AUSDRUCK} auf Wahrheit prüfen }
  \begin{itemize}
    \item[wahr]{ zurück zu (0) }
    \item[unwahr]{ Schleife beenden }
  \end{itemize}
\end{enumerate}

\end{columns}

\end{frame}

\begin{frame}[fragile]{Schleifen: \texttt{while} \texttt{do-while} (2/2)}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
Wir wollen folgende unendliche Summe berechnen:
\begin{equation*}
  S=\sum_{n=0}^\infty x^n, \quad |x| < 1
\end{equation*}
\end{block}

\begin{lstlisting}
const double x = 0.8;         // x ist eine Konstante
double S = 0.0;               // S_0 = 0
double xn = 1.0;              // x^0 = 1.0
while( xn > 1.0e-12 ){        // Test auf x^n > 1,0 * 10^{-12}
  S = S + xn;
  xn = xn * x;                // x^n
}
\end{lstlisting}
\begin{lstlisting}
do {
  S += xn;
  xn *= x;
while( xn > 1.0e-12 );
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Schleifen: \texttt{for} (1/2)}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  In C hat eine \texttt{for}-Schleife Kontrollelemente im Schleifenkopf, ideal um mit einer Zählvariable zu arbeiten (aber auch andere Konstrukte sind möglich).
\end{block}
\begin{lstlisting}
for( INITIALISIERUNG; LOGISCHER AUSDRUCK; SCHRITT ){
  BEFEHLE
}
\end{lstlisting}
\begin{enumerate}
  \item[(0)]{\texttt{INITIALISIERUNG} wird ausgeführt}
  \begin{enumerate}
    \item[(1)]{\texttt{LOGISCHER AUSDRUCK} wird auf Wahrheit geprüft}
    \begin{enumerate}
      \item[wahr]{Weiter zu (2)}
      \item[unwahr]{Schleife beenden}
    \end{enumerate}
    \item[(2)]{\texttt{BEFEHLE} werden ausgeführt}
    \item[(3)]{\texttt{SCHRITT} wird ausgeführt}
    \item[$\Rightarrow$]{Zurück zu (1)}
  \end{enumerate}
\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Schleifen: \texttt{for} (2/2)}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
Die Berechnung der Summe $\sum_{n=0}^{\infty} \, x^n$, könnte man, z.B. so implementieren:
\end{block}
\begin{lstlisting}
const double x = 0.8;
double S = 0.0;
double xn = 1.0;
for( unsigned int n = 0; n < 1000; ++n ){  // max. 1000 Iterationen
  S = S + xn;
  if( xn < 1.0e-12 ){
    break;                        // aus der Schleife ausbrechen
  }                               // selbst wenn n < 1000
  xn = xn * x;
}
\end{lstlisting}

\begin{block}{}
Oder aber auch so:
\end{block}
\begin{lstlisting}
const double x = 0.8;
double S = 0.0;
for( double xn = 1.0; xn > 1.0e-12; xn *= x){
  S += xn;
}
\end{lstlisting}
\end{frame}

\stepcounter{lecturecounter}

\begin{frame}{Fragen zu Vorlesung 1}
  In der letzten Vorlesung:
  \begin{itemize}
    \item{Rechnerarchitektur}
    \item{Dualsystem}
    \item{Fließkommazahlen}
    \item{(sehr knappe) Einführung in Algorithmen und Pseudocode}
    \item{Erstes C-Programm}
    \item{Kompilieren und Ausführen}
    \item{Datentypen}
    \item{Operatoren}
    \item{Kontrollstrukturen}
    \begin{itemize}
      \item{\texttt{if / else if / else}}
      \item{Schleifen}
      \begin{itemize}
        \item{\texttt{do-while}, \texttt{while}}
        \item{\texttt{for}}
      \end{itemize}
    \end{itemize}
  \end{itemize}
  \textbf{Heute:} Biete: mehr Demos. Suche: mehr kritische Fragen, fallen Sie mir ins Wort, bitte! Auch die Tutoren!
\end{frame}

\begin{frame}{Wieso eigentlich C?}{Vorlesung 1 Addendum}
  In den nächsten beiden Tagen wird Ihnen vielleicht klar werden, dass einige Aspekte von C doch komplizierter sind, als man glaubt. Wieso also C nutzen und nicht Python?
  \vspace{0.3cm}
  \begin{itemize}
    \item{C und C++ schaffen einen Spagat zwischen Nähe an der Hardware und einer relativ einfachen Sprachsyntax.}
    \begin{itemize}
      \item{Wissenschaftliche Software muss oft so schnell wie möglich sein.}
      \item{Effiziente Programmierung und gute Compiler machen dies in C und C++ möglich.}
    \end{itemize}
    \vspace{0.4cm}
    \item{In der Wissenschaft gibt es unglaublich viel Software die ursprünglich in C geschrieben wurde oder immer noch geschrieben wird. In Bacheror- Master- oder Doktorarbeiten, werden Sie damit in Kontakt kommen und müssen die ``hässlichen'' Grundlagen ein Mal gesehen haben.}
    \vspace{0.4cm}
    \item{Andere Sprachen machen ``unter der Motorhaube'' nichts anderes als C. Zu verstehen, was genau der Rechner da tun muss, hilft zu verstehen, wieso einige Dinge ineffizient sein könnten.}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Textausgabe Mini-Intro}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{\texttt{printf} und die Formatspezifikation}
    \texttt{printf} ist eine Funktion zur \emph{formatierten} Textausgabe in der Konsole.
    Um verschiedene Datentypen auszugeben, muss man Platzhalter nutzen.
  \end{block}
  \begin{center}
  \begin{tabular}{lr}
    \hline
    \texttt{Platzhalter} & Bedeutung \\\hline
    \texttt{\%d}        &  \texttt{int} \\
    \texttt{\%ld}  &  \texttt{long int} \\
    \texttt{\%lld} &  \texttt{long long int} \\
    \texttt{\%ud}  &  \texttt{unsigned int} \\
    \texttt{\%llu} &  \texttt{long long unsigned int} \\
    \texttt{\%f,\%e}   & \texttt{float} \\
    \texttt{\%lf,\%le}  & \texttt{double} \\
    \hline
  \end{tabular}
  \end{center}  
  \begin{block}{}
    $\Rightarrow$ Mal ausprobieren! (\verb|test_printf.c|)
  \end{block}
\end{frame}

\begin{frame}[fragile]{Funktionen}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{}
    C-Programme bestehen im Wesentlichen aus Funktionsdefinitionen und Funktionsaufrufen, sowie eingebauten und eigenen Datentypen. Ein komplexes C-Programm ruft viele Funktionen auf, welche wiederum Funktionen aufrufen.
  \end{block}
  \centering
  \includegraphics[height=7cm]{graphics/call_graph}
\end{frame}

\begin{frame}[fragile]{Funktionen: Definition}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
In der letzten Vorlesung hatten wir ein Programm entwickelt um eine Annäherung an die unendliche Summe
\begin{equation*}
  S=\sum_{n=0}^\infty x^n, \quad |x| < 1
\end{equation*}
zu bestimmen.
\end{block}
\begin{lstlisting}
const double x = 0.8;
double S = 0.0;
double xn = 1.0;
for( unsigned int n = 0; n < 1000; ++n ){  // max. 1000 Iterationen
  S = S + xn;
  if( xn < 1.0e-12 ){
    break;                        // aus der Schleife ausbrechen
  }                               // selbst wenn n < 1000
  xn = xn * x;
}
\end{lstlisting}
\textbf{Wir wollen nun mit einer Funktion die Berechnung auslagern und verallgemeinern.} (\verb|sum_xn_funktion.c|)
\end{frame}

\begin{frame}[fragile]{Funktionen: Funktionskopf und Signatur}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  Eine Funktion wird dem Compiler bekannt gemacht, indem ihr Name und die Datentypen ihrer Argumente festgelegt werden. $\Rightarrow$ \emph{Funktionsdeklaration}
\end{block}

\begin{lstlisting}
RUECKGABETYP FUNKTIONSNAME( ARGUMENT1_TYP ARG1, ARGUMENT2_TYP ARG2,
                            ARGUMENT3_TYP ARG3 );
\end{lstlisting}
\begin{block}{Signatur}
  Dies nenn man auch die \emph{Signatur} der Funktion.
  {\footnotesize \verb| (FUNKTIONSNAME) ( ARGUMENT1_TYP, ARGUMENT2_TYP, ARGUMENT3_TYP ) | }
\end{block}
\textbf{Korrektur aus der Vorlesung:} Es darf nur eine Funktion mit dem Namen \texttt{FUNKTIONSNAME}.
\end{frame}

\begin{frame}[fragile]{Funktionen: Funktionsaufruf und Rückgabewert}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
Hat eine Funktion einen Rückgabewert, so kann man diesen beim Aufruf einer Variable zuweisen:
\begin{lstlisting}
double result = teilen( 8.0, 3.2 );  
\end{lstlisting}
\end{block}
\begin{block}{}
Man kann den Rückgabewert aber auch einer anderen Funktion als Argument übergeben:
\begin{lstlisting}
addieren( teilen(8.0, 3.2), 4.5 );
\end{lstlisting}
\begin{itemize}
  \item{Was macht dieser Code?} 
\end{itemize}
\end{block}
\begin{block}{}
Oder aber man ignoriert den Rückgabewert, wie wir es bei \texttt{printf([...])} getan haben (Gesamtzahl der geschriebenen Zeichen).
\end{block}
\end{frame}

\begin{frame}[fragile]{Funktionen: Deklaration und Definition}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  Die \emph{Funktionsdeklaration} informiert den Compiler über die Existenz und Signatur einer Funktion
\begin{lstlisting}
double power( const double, const int );
\end{lstlisting}
\end{block}
\begin{block}{}
  Die \emph{Funktionsdefinition} beschreibt erst, wie diese Funktion ihre Aufgabe erfüllt.
\end{block}
Funktionsdeklarationen führen einerseits zu lesbarerem Code, finden aber andererseits Verwendung in der \emph{modularen Programmierung}, die wir in den nächsten Tagen kennenlernen werden.

\textbf{Erstmal ein Beispiel.} (\verb|funktion_deklaration.c|)
\end{frame}

\begin{frame}[fragile]{Funktionen: Rekursion}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{Rekursion}
    Eine Funktion, die sich selbst aufruft, nennt man \emph{rekursiv}. Rekursion kann man oft nutzen, um Aufgaben auf fast magische Art und Weise zu lösen. Leider birgt Rekursion auch viele Gefahren.
  \end{block}
\begin{lstlisting}
TYP rekursion( TYP arg ){
  if( [...] ){ // Ziel erreicht!
    return arg;
  } else {
    return rekursion( arg ); // noch einmal tiefer verschachteln!
  }
}
\end{lstlisting}
   \textbf{Versuchen wir mal, unsere Summe rekursiv auszurechnen!} (\verb|sum_xn_rekursiv.c|)
\end{frame}
 
\begin{frame}[fragile]{\texttt{gdb} und \texttt{valgrind}}
\begin{block}{}
  Nanu, was ist denn da schiefgegangen? Ein Debugger, ist ein Programm, mit dem man Fehler in anderen Programmen versuchen kann nachzuvollziehen.
\end{block}
\begin{block}{Debugging-Symbole mit einbinden und Programm in \texttt{gdb} ausführen}
\begin{verbatim}
$ gcc -Wall -Wpedantic -g -ggdb -std=c99 \
  -o sum_xn_rekursiv_DEBUG sum_xn_rekursiv.c
$ gdb ./sum_xn_rekursiv_DEBUG
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1
(gdb) run
\end{verbatim}
\end{block}

\begin{block}{\texttt{valgrind}}
Ein weiteres nützliches Programm ist \texttt{valgrind}. Es ist eigentlich kein Debugger im eigentlichen Sinne, ist aber spezialisiert darauf, Speicherfehler zu erkennen.
\begin{verbatim}
$ valgrind ./sum_xn_rekursiv_DEBUG
\end{verbatim}
\end{block}
\end{frame}

\begin{frame}[fragile]{Statische Arrays}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{}
    Oft brauchen wir viele Daten des gleichen Datentyps. Diese kann man praktisch in \emph{Arrays} abspeichern.
  \end{block}

\begin{lstlisting}
DATENTYP NAME[ANZAHL];
\end{lstlisting}
Hierbei muss, selbst in C99, \texttt{ANZAHL} fast immer eine numerische Konstante sein!

\begin{lstlisting}
double a[3];  // Array mit 3 double deklarieren

double b[3] = {1.0, 2.3, 9.9};  /* Array mit 3 double deklarieren
                                   und initialisieren */

double c[4] = {4.5, 7.3}; /* Die ersten beiden Elemente mit 
                             4.5 und 7.3 initialisieren,
                             alle anderen werden mit 0.0 
                             initialisiert */
                                   
a[1] = 0.0001; // 0.0001 im zweiten Element von v abspeichern
\end{lstlisting}
\textbf{$\Rightarrow$ Wir möchten nun für unsere Annäherung an die unendliche Summe alle Terme abspeichern und ausgeben!} (\verb|sum_xn_alleterme.c|)
\end{frame}

\begin{frame}[fragile]{Mini-Intro: Texteingabe}{Vorlesung \arabic{lecturecounter}}
\begin{block}{Der Adressoperator \texttt{\&}}
  Für jede Variable, jedes Datentyps, gibt \texttt{\&} die Speicheradresse der Variable zurück. (Um genauer zu sein, ist der Rückgabewert ein Zeiger auf ein Objekt des ensprechenden Datentyps)
\end{block}
\begin{block}{Eingabe mit \texttt{scanf}}
  Die Funktion \texttt{scanf} kann als umgekehrtes \texttt{printf} verstanden werden.
\end{block}
\begin{lstlisting}
int ganzzahl; double dezimalzahl;
scanf("%d %lf",&ganzzahl, &dezimalzahl);
\end{lstlisting}
\textbf{Probieren wir mal, ob wir so unser Summenprogramm weiter verallgemeinern können.} (\verb|test_scanf.c| und \verb|sum_xn_eingabe.c|)
\end{frame}

\begin{frame}[fragile]{Preview: Zeiger auf Daten}{Vorlesung \arabic{lecturecounter}}
\begin{block}{Zeigervariablen}
  Eine Zeigervariable speichert die Adresse einer Variable für einen bestimmten Datenyp.
\end{block}
\begin{block}{Dereferenzierungsoperator \texttt{*}}
  Dieser Operator gibt Zugriff zu den Daten, auf die der Zeiger zeigt.
\end{block}
$\Rightarrow$ \textbf{Tafelbild +} (\texttt{zeiger\_preview.c})
\end{frame}

\stepcounter{lecturecounter}

\begin{frame}[fragile]{Fragen zu Vorlesung 2}{Vorlesung \arabic{lecturecounter}}
  \begin{itemize}
    \item{Platzhalter in \texttt{printf}}
    \item{C-Programme als Funktionssammlungen}
    \item{Funktionen: Kopf, Signatur, Aufruf, Deklaration, Definition, Rückgabewert, Rekursion}
    \item{Debugger Mini-Mini-Intro}
    \item{Statische Arrays}
    \item{Texteingabe mit \texttt{scanf}}
    \item{Preview: Zeiger}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Zeiger}{Vorlesung \arabic{lecturecounter}}
  \includegraphics[width=\textwidth,page=1,trim=0 7cm 0 2cm,clip=true]{graphics/c_kurs_tafel}
  \begin{block}{}
    Zeiger sind Datentypen, welche die Adresse einer Variable oder, allgemein, eines Speicherbereichs darstellen.
  \end{block}
  $\Rightarrow$ (\texttt{zeiger\_demo.c}) und Tafelbild
  \begin{block}{}
    Ein \texttt{NULL}-pointer zeigt auf gar nichts. (Strikt gesehen falsch: zeigt auf Adresse '0', diese Adressee darf nicht derefernziert werden! [segmentation fault])
  \end{block}
\end{frame}

\begin{frame}[fragile]{Arrays, Zeiger und einfache Zeigerarithmetik}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{}
    Statische Arrays sind spezielle Speicherbereiche, für die der Compiler einen Standardzeiger setzt. Dieser Zeiger ist der Name des Arrays.
  \end{block}
\begin{lstlisting}
int a[4];   /* 'a' hat Datentyp (int*) und zeigt  
               auf ein Array des Typs (int) */
int *b = a; /* 'b' hat auch den Datentyp (int*) und zeigt jetzt
               auf den gleichen Speicherbereich wie 'a' */
\end{lstlisting}
\begin{block}{}
  Strikt gesehen sind arrays und Zeiger (\emph{pointer}) auf Daten des gleichen Datentyps aber nicht identisch!
\end{block}
 $\Rightarrow$ (\texttt{zeiger\_array\_demo.c}) und Tafelbild

\end{frame}

\begin{frame}[fragile]{Zeichenketten}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{}
    \begin{itemize}
      \item{Die Manipulation von Zeichenketten (auch \emph{strings}) ist in vielen Programmen von zentraler Bedeutung, z.B. um Dateinamen für Ausgabedateien zu setzen.}
      \item{In C werden einfache strings in \texttt{char}-Arrays gespeichert. Da \texttt{char} nur 1B groß ist, stehen einem bloß 255 verschiedene Zeichen zur Verfügung.}
      \item{Strings werden in C \emph{null-terminiert}: Am Ende eines Strings steht ein spezielles Zeichen, welches man auch selbst mit '\textbackslash 0' einfügen kann.}
      \item{Ein C String ist also ein \texttt{char}-Array der Länge $n$ für maximal $n-1$ Zeichen.}
    \end{itemize}
  \end{block}
  \begin{lstlisting}
    // dies ist ein string
    char begruessung[20] = "Hallo, Welt!\n";
    printf("%s", begruessung);
  \end{lstlisting}
  $\Rightarrow$ (\verb|test_strings.c|)
\end{frame}

\begin{frame}[fragile]{Zeichenketten bearbeiten: \texttt{snprintf}}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{}
    \begin{itemize}
      \item{C enthlält viele Funktionen zur Manipulation von Zeichenketten. Fast alle sind unsicher.}
      \item{Es gibt eine Ausnahme: \texttt{snprintf}}
    \end{itemize}
  \end{block}
  (\verb|unsichere_Zeichenketten.c|)  und (\verb|test_snprintf.c|)
\end{frame}

\begin{frame}[fragile]{\emph{Pass-by-reference}: Zeiger an Funktionen übergeben}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{}
    Wie wir gesehen haben, existieren Variablen in C -- sofern es sich nicht um globale Variablen handelt -- nur innerhalb eines Blocks. Aus Effizienzgründen ist es oft aber unratsam, Kopien großer Datenstrukturen hin- und herzuschieben.
  \end{block}
  Wir können aus der Funktion \texttt{inkrement}, nicht einfach so auf \texttt{x} aus der Funktion \texttt{main} zugreifen.
  \begin{lstlisting}
int inkrement(int n){
  x += n; // Fehler: 'inkrement' kennt 'x' nicht!
}  
int main(void){
  int x = 22;
  inkrement(4); // Fehler: 'inkrement' kennt 'x' nicht!
  return 0;
} 
\end{lstlisting}
\vspace{-0.4cm}
  \begin{block}{}
    Mithilfe von Zeigern, können wir Funktionen direkt auf Daten anwenden, welche in einem anderen Block deklariert wurden. (wie bei \texttt{scanf} gemacht)
  \end{block}
  $\Rightarrow$  nächste Folie
\end{frame}

\begin{frame}[fragile]{\emph{Pass-by-reference}: Zeiger an Funktionen übergeben}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{}
    Übergeben wir die Adresse von \texttt{x} an die Funktion, hat diese direkten Zugriff auf die Variable \texttt{x} aus der \texttt{main}-Funktion.
  \end{block}
  \begin{lstlisting}
int inkrement(int *z_x, int n){
  *z_x += n;
}  
int main(void){
  int x = 22;
  inkrement(&x, 4); // x wird von 'inkrement' um 4 inkrementiert
}
\end{lstlisting}
\vspace{-0.4cm}
  \begin{block}{}
    Das können wir auch anhand unserer Summenfunktion zeigen:
  \end{block}
  $\Rightarrow$ (\verb|sum_xn_by_reference.c|)
\end{frame}

\begin{frame}[fragile]{Kommandozeilenargumente}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  In unseren Programmen haben wir bisher
\end{block}
\begin{lstlisting}
  int main(void){ [...] } 
\end{lstlisting}
\begin{block}{}
  geschrieben. \texttt{void} bedeutet leer oder auch ungültig. Wir haben damit darauf hingedeutet, dass unsere \texttt{main}-Funktion keine Argumente entgegennimmt.
  \begin{itemize}
    \item{Der \texttt{main}-Funktion werden aber vom Betriebssystem Argumente übergeben: die Kommandozeilenargumente}
  \end{itemize}
\begin{verbatim}
$ ./programm arg0 arg1 arg2
\end{verbatim}
\begin{lstlisting}
int main(int argc, char **argv){
  [...]
}
\end{lstlisting}

\end{block}
$\Rightarrow$ (\texttt{test\_argc.c})
\end{frame}

\begin{frame}[fragile]{Kommandozeilenargumente auslesen}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{}
    \begin{itemize}
      \item{Bei \texttt{**argv} (oder auch \texttt{*argv[]}) handelt es sich um ein Array von Strings (ein Array von \texttt{char}-Arrays).}
      \item{C bietet einige Funktionen, die es erlauben aus Strings andere Datentypen auszulesen.}
      \item{\texttt{sscanf} ist eine mit \texttt{scanf} verwandte Funktion zum Auslesen einzelner Elementer aus formatierten Texten in Variablen}
      \item{Für Kommandozeilenargumente ist es oft praktischer einfachere Funktionen zu nutzen.}
      \begin{itemize}
        \item{\verb|atoi, atof, strtod, strtol, strtoul, strtoull|}
      \end{itemize}
      \item{Aber Vorsicht: \verb|atoi| und \verb|atof| prüfen nicht auf Fehler!}
    \end{itemize}
  \end{block}
  $\Rightarrow$ (\verb|test_read_argv.c|)
\end{frame}

\stepcounter{lecturecounter}

\begin{frame}[fragile]{Fragen zu Vorlesung 3?}{Vorlesung \arabic{lecturecounter}}
  \begin{itemize}
    \item{Zeiger auf Variablen verschiedener Typen}
    \item{Arrays und Zeiger}
    \item{Zeichenketten}
    \item{Zeichenketten bearbeiten}
    \item{Kommandozeilenargumente}
  \end{itemize}
  \vspace{0.5cm}
  Heute gibt es ein physikalisches Beispiel! (yaaay).
\end{frame}

\begin{frame}[fragile]{Rückblick: Zeiger}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
Die Notation für Zeiger in C ist auf den ersten Blick (meiner Meinung nach) etwas unklar $\rightarrow$ Rückblick
\end{block}
\begin{lstlisting}
  double x; double y; // zwei double Variablen deklarieren
  double arr_y[10]; // und ein double Array mit 10 Elementen
  
  double *z_x, *z_y, w; /* zwei Zeiger auf double ('z_x' und 'z_y')
                         * und ein double ('w') */
   
  z_x = &x; // 'z_x' zeigt jetzt auf 'x'
  z_y = &y; // 'z_y' zeigt jetzt auf 'y'
  
  *z_y = 4.2; // 'z_y' derefernzieren und 'y' auf 4.2 setzen
  
  z_y = arr_y; // Zeiger 'z_y' zeigt jetzt auf 'arr_y'
  
  z_y[0] = 6.2; // erstes Element von 'arr_y' auf 6.2 setzen
  
  z_x = &w; // 'z_x' zeigt jetzt auf 'w'
  
  *z_x = 5.4; // 'w' wird auf 5.4 gesetzt
\end{lstlisting}
  
\end{frame}


\begin{frame}[fragile]{Modulare Programmierung}{Vorlesung \arabic{lecturecounter}}
\includegraphics[width=\textwidth,page=2,trim=0 10cm 0 2cm,clip=true]{graphics/c_kurs_tafel}
\begin{block}{}
  \begin{itemize}
    \item{Themenspezifische Funktionssammlungen können in C in separaten Quelltextdateien stehen und unabhängig voneinander kompiliert werden.}
  \end{itemize}
\begin{enumerate}
  \item{Funktionen in separate Dateien auslagern}
  \item{Einzelne Module kompilieren \\ \texttt{\$ gcc \textcolor{red}{-c} modulX.c} $\rightarrow$ \texttt{modulX.o}}
  \item{Module zu Programm verlinken \\ \texttt{\$ gcc -o programm modul1.o modul2.o}}
\end{enumerate}
\end{block}
\end{frame}

\begin{frame}[fragile]{Modulare Programmierung: Quell- und \emph{Header}-dateien}{Vorlesung \arabic{lecturecounter}}
\small $x$ sei ein Array, welches die $1D$ Position eines Teilchens zur Zeit $t$ enthält. Wir wollen die kinetische Energie berechnen. Die einzelnen \texttt{x[i]} liegen im Abstand von $dt=0.01$.
\begin{columns}[T]
  \column{0.49\textwidth}
    \begin{lstlisting}
#include "AblT.h"
double 
kinEnerg( double *x, 
          double m, 
          unsigned int t ) {
  double v = AblT( x, t );
  return 0.5*m*v*v;
}
    \end{lstlisting}
    \texttt{kinEnerg.c}
    \vspace{0.1cm}
    \begin{lstlisting}
double AblT( double *x, 
             unsigned int t ){
  double dt = 0.01;
  return (x[t+1]-x[t])/dt;
}
    \end{lstlisting}
    \texttt{AblT.c}
  \column{0.49\textwidth}
    \begin{lstlisting}
double kinEnerg( double*, double,
                 unsigned int );
    \end{lstlisting}
    \texttt{kinEnerg.h} \\
    \textcolor{red}{Hier sind die Funktionsdeklarationen.}
    \vspace{2.0cm}
    \begin{lstlisting}
double AblT( double*, 
             unsigned int );
    \end{lstlisting}
    \texttt{AblT.h}  
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Compiler und Linker}{Vorlesung \arabic{lecturecounter}}
  Die Kompilerung und das \emph{Linken} sind unabhängige Schritte bei der Erstellung eines ausführbaren Programms.
\begin{block}{Kompilierung}
  \begin{verbatim}
    # erstellt kinErg.o Objketdatei
$ gcc -c kinEnerg.c

    # erstellt AblT.o   Objektdatei
$ gcc -c AblT.c       

    # erstellt teilchen.o   Objektdatei
$ gcc -c teilchen.c       

    # erstellt ausführbares Programm
$ gcc -o teilchen teilchen.o AblT.o kinEnerg.o 
  \end{verbatim}
\end{block}
$\Rightarrow$ ( \verb|teilchen/kinErg.c teilchen/AblT.c teilchen/teilchen.c|)
\end{frame}

\begin{frame}[fragile]{Modulare Programmierung: Interface und Implementierung}{Vorlesung \arabic{lecturecounter}}
Trennung Interface/Implementierung $\rightarrow$ Implementierung austauschbar!
\begin{columns}[T]
  \column{0.49\textwidth}
    \begin{lstlisting}
#include "AblT.h"
double 
kinEnerg( double *x, 
          double m, 
          unsigned int t ) {
  double v = AblT( x, t );
  return 0.5*m*v*v;
}
    \end{lstlisting}
    \texttt{kinEnerg.c}
    \vspace{0.1cm}
    \begin{lstlisting}
double AblT( double *x, 
             unsigned int t ){
  double dt = 0.01;
  return @(x[t+1]-x[t-1])/(2*dt)@;
}
    \end{lstlisting}
    \texttt{AblT\_symmetrisch.c}
  \column{0.49\textwidth}
    \begin{lstlisting}
double kinEnerg( double*, double,
                 unsigned int );
    \end{lstlisting}
    \texttt{kinEnerg.h}
    \vspace{2.4cm}
    \begin{lstlisting}
double AblT( double*, 
             unsigned int );
    \end{lstlisting}
    \texttt{AblT.h}  
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Der C-Präprozessor}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  \begin{itemize}
    \item{Wir haben bisher einen Teil des Kompilierprozesses ausgelassen: den Präprozessor.}
    \item{Bevor der Compiler seinen Dienst verrichtet, wird der Quelltext vom Präprozessor bearbeitet.}
  \end{itemize}
\end{block}
\begin{block}{Präprozessorkonstanten und Makros}
  Ein Makro ist ein Stück Code mit einem Namen, welches vom Präprozessor beim Durchlauf in den Quelltext eingefügt wird.
\end{block}
\begin{lstlisting}
// MY_PI wird der Wert des Textes bis zum Ende der Zeile zugewiesen
#define MY_PI 3.1415
\end{lstlisting}
\begin{itemize}
  \item{Schreiben wir jetzt in unserem Programm \verb|MY_PI|, ersetzt der Präprozessor, bevor die Datei kompiliert wird, \verb|MY_PI| durch \texttt{3.1415}}
  \item{Mit den Präprozessorkommandos \verb|#ifdef| und \verb|#ifndef| kann man im Präprozessor die Existenz eines Makros überpüfen}
\end{itemize}
$\Rightarrow$ (\verb|test_makros.c|)
\end{frame}

\begin{frame}[fragile]{Include Guards}{Vorlesung \arabic{lecturecounter}}
\begin{lstlisting}
#include "xyz.h" // "xyz.h" wird eingebunden
\end{lstlisting}
\begin{block}{}
  Wenn eine Header-datei in einem Program mehrfalls eingebunden wird, muss sichergestellt sein, dass die darin enthaltenen Definitionen und Deklaration nur einmal durchgeführt werden! $\rightarrow$ \emph{include guards}
\end{block}
\begin{lstlisting}
#ifndef ABLT_H
#define ABLT_H
double AblT( double*, 
             unsigned int );
#endif // um welches #if[n]def handelt es sich hier? ABLT_H!
\end{lstlisting}
\begin{block}{}
  \begin{enumerate}
    \item{\texttt{AblT.h} wird das erste Mal eingebunden: \verb|ABLT_H| ist nicht definiert.}
    \begin{itemize}
      \item{Definiere \verb|ABLT_H| und deklariere Funktion}
    \end{itemize}
    \item{\texttt{AblT.h} wird zum $(1+n)$-ten Mal eingebunden:}
    \begin{itemize}
      \item{\verb|ABLT_H| ist schon definiert $\rightarrow$ überspringe alles bis zu \texttt{\#endif}} 
    \end{itemize}
  \end{enumerate}
\end{block}
$\Rightarrow$ (\verb|test_include.c|)
\end{frame}

\begin{frame}[fragile]{Zusammengesetzte Datenstrukturen}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
Konzeptionell ist es oft ratsam, mehrere Variablen zu einem \emph{struct} zusammenzufassen.
Die Position unseres Teilchens könnte in zwei Dimensionen z.B. mit folgender Datenstruktur dargestellt werden:
\end{block}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
struct Position_st {
  double x;
  double y;
};  // Achtung: nach struct Deklaration -> Semikolon

// Variable "teilchen1" vom Typ "struct Position_st"
struct Position_st teilchen1;

teilchen1.x = 1.2;  // Zugriff auf Elemente ueber '.' 
teilchen1.y = 1.3;

struct Position_st teilchen2[1000]; // Array von struct
teilchen2[0].x = 8.3; // Zugriff auf struct-Elemente 
teilchen2[0].y = 4.2; // im Array teilchen2

struct Position_st *z_t; // Zeiger auf "struct Position_st"
z_t = &teilchen1;
z_t->x = 3.3; // Zugriff auf Elemente ueber Zeiger 'z_t' und '->'
\end{lstlisting}
\vspace{-0.1cm}
$\Rightarrow$ (\verb|test_struct.c|)
\end{frame}

\begin{frame}[fragile]{Vorschau: Vorlesung 5}
  \begin{itemize}
    \item{Wünsche?}
    \vspace{0.3cm}
    \item{Mehrdimensionale Arrays}
    \vspace{0.3cm}
    \item{Dynamische Speicherverwaltung}
    \begin{itemize}
      \item{Sicherer Umgang mit Speicher!}
    \end{itemize}
    \vspace{0.3cm}
    \item{Dynamische Arrays}
  \end{itemize}
\end{frame}

\stepcounter{lecturecounter}

\begin{frame}[fragile]{Fragen zu Vorlesung 4?}
  \begin{itemize}
    \item{Modulare Programmierung}
    \item{Trennung: Interface / Implementation }
    \begin{itemize}
      \item[$\Rightarrow$]{\verb|04/test_include.c| enthält jetzt vollen Test für \emph{Include Guards}}
      \item[$\Rightarrow$]{\verb|04/test_makros.c|: Eulersche Zahl in Header-datei mit Include Guards}
    \end{itemize}
    \vspace{0.3cm}
    \item{Zusammengesetzte Datenstrukturen}
    \begin{itemize}
      \item{Addendum: ein \texttt{struct} darf natürlich Elemente verschiedener Datentypen enthalten!}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Vervollständigung: Quell- und Headerdateien}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{}
    \small
    \begin{itemize}
      \item{Header- und Quelldateien trennen Interface und Implementierung.}
      \item{Erlaubt iterative Entwicklung: Aufgabe in Algorithmen aufteilen, Interfaces überlegen, Verbindungen aufstellen, Schritt für Schritt implementieren.}
      \item{Benötigte Datenstrukturen können auch in den themengebundenen Headerdateien deklariert werden.}
    \end{itemize}
  \end{block}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
#ifndef ZWEID_MECHANIK_H
#define ZWEID_MECHANIK_H
struct zweiD_vektor_st {
  double x;
  double y;
};
struct zweiD_vektor_st AblT_zweiD( double dt, struct zweiD_vektor_st *pos,
                                   unsigned int t, unsigned int tmax );
#endif // ifndef(ZWEID_MECHANIK_H)
\end{lstlisting}
\vspace{-0.2cm}
\begin{block}{}
  Alternativ könnte man die Deklaration des \verb|struct| auch in eine eigene Header-datei verschieben. (emfohlen)
\end{block}
\end{frame}

\begin{frame}[fragile]{Vervollständigung: Zeiger auf lokale Variablen}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{}
    Die Rückgabe von Zeigern auf lokale Variablen ist nicht zulässig.
  \end{block}
  \begin{lstlisting}
double* test_ptr(void){
  double v = 4.2; // v existiert nur innerhalb des Funktionsblocks!
  return &v; // Compiler warnt, aber kein Fehler!
}
int main(void){
  double *z_v = test_ptr(); // legale Zuweisung, kein Fehler!
  printf("%lf\n", *z_v ); // Segmentation Fault bei Dereferenzierung!
  return 0;
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Zeigerarithmetik 1}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  Wir hatten die Analogie zwischen Zeigern und Arraynamen schon mehrfach angedeutet. Die folgende Zeigerzuweisungen sind identisch.
\end{block}
\begin{lstlisting}
int k[40]; // int Array mit 40 Elementen
int *z1_k = k;     // Der Arrayname 'k'
int *z2_k = &k[0]; // Die Adresse des ersten Elements von 'k[]'
int *z3_k = z2_k;  // Der Wert des int-Zeigers 'z2_k'
\end{lstlisting}
\begin{block}{}
  Ein Zeiger kann inkrementiert werden. Addition/Subtraktion mit ganzzahligen Konstanten oder Variablen ist ebenso möglich. 
\end{block}
\begin{lstlisting}
z1_k++; z1_k++; // 'z1_k' wird zwei Mal inkrementiert
z2_k = &k[2];   // Adresse des dritten Elements von 'k[]'
int delta_k = 2;
z3_k = z3_k + delta_k; // z3_k um '2' erhoehen
\end{lstlisting}
\begin{block}{}
  Alle drei Zeiger zeigen auf das dritte Element des Arrays \texttt{k}.
\end{block}
$\Rightarrow$ (\verb|test_zeigerarithmetik.c|)
\end{frame}

\begin{frame}[fragile]{Zeigerarithmetik 2}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  \texttt{k} ist ein \texttt{int}-Array mit $10$ Elementen, initialisiert mit $\lbrace 42, 55, 17, 34, 421, 17, 11, 9, 117, 629 \rbrace$. Wenn Sie jede Gleichheit verstehen, haben Sie Zeigerarithmetik verstanden.
\end{block}
\centering
\includegraphics[page=3,width=0.8\textwidth,clip=true,trim=0 3cm 0 2cm]{graphics/c_kurs_tafel}
\begin{block}{}
  $\Rightarrow$ \verb|k[n]| ist ein praktisches Kürzel für \verb|*(k+n)|.
\end{block}

\end{frame}

\begin{frame}[fragile]{Dynamische Speicherverwaltung}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{\texttt{malloc} und \texttt{free}}
    \begin{itemize}
      \item{Speicher wird in C mit \texttt{malloc} allokiert und mit \texttt{free} wieder freigegeben.}
      \item{Man sollte immer überprüfen, ob einer Allokation erfolgreich war.}
      \item{Wenn man den Speicher nicht mehr braucht, muss er freigegeben werden, sonst entstehen \emph{memory leaks}.}
    \end{itemize} 
  \end{block}
\begin{lstlisting}
  int n = 300;
  // Platz fuer 300 'double'-Variablen allokieren
  double *x = malloc( sizeof(double) * n );
  if( x == NULL ){
    printf("Speicherallokation fuer 'x' fehlgeschlagen!\n"); 
    exit(32); // Rueckgabewert > 0 bedeutet Fehler
  }
  x[23] = 4.2; x[3] = 2.4; [...] // 'x' verwenden
  free(x); /* Speicher 'x' wird nicht mehr gebraucht
            * -> freigeben */
  /* Programm geht weiter */
\end{lstlisting}
$\Rightarrow$ (\verb|test_malloc.c|)
\end{frame}

\begin{frame}[fragile]{Memory Leaks}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  \begin{itemize}
    \item{Wird ein Speicherbereich $a$ einem Zeiger zugewiesen und dann ein weiterer Speicherbereich, $b$, dem gleichen Zeiger zugewiesen, geht die Adresse von $a$ verloren. $\rightarrow$ Speicherleck (memory leak)}
    \item{Der Speicher ist belegt und kann, bis das Programm beendet wird, nicht freigegeben werden.}
    \item{Memory leaks sind Bugs, welche oft erst in den unangenehmsten Situationen auftauchen. Man sollte seine Programme überprüfen wenn möglich.}
  \end{itemize}
\end{block}
\begin{lstlisting}
// Platz fuer 100 'double'-Variablen allokieren
double *x = malloc( sizeof(double) * 100 );
/* x wird einem anderen Speicherbereich zugewiesen
 *   -> Speicherleck */
x = malloc( sizeof(double) * 55 );
free(x); /* free'd nur "malloc( sizeof(double) * 55 )"
          * verloren: "malloc( sizeof(double) * 100 )" */
\end{lstlisting}
$\Rightarrow$ (\verb|memory_leak.c|)
\end{frame}

\begin{frame}[fragile]{Mehrdimensionale Arrays}{Vorlesung \arabic{lecturecounter}}
\begin{block}{Statische Mehrdimensionale Arrays}
  Ein statisches mehrdimensionales Array hat in C eine relativ einleuchtende Notation.
\end{block}
\begin{lstlisting}
double A[3][3];    // 3x3 double Matrix
double B[2][5][7]; // 2x5x7 Tensor mit 3 Indices
\end{lstlisting}
\begin{block}{}
  Ein statisches mehrdimensionales Array ist ein spezielles Objekt in C. Es liegt als ein linearer Datenblock im Speicher.  
\end{block}
\centering
\includegraphics[page=4,width=0.8\textwidth,clip=true,trim=0 12cm 0 2cm]{graphics/c_kurs_tafel}
\begin{block}{}
  Dynamische mehrdimensionale Arrays werden genauso angelegt, um den Zugriff effizient zu machen.
\end{block}
\end{frame}

\begin{frame}[fragile]{Linearisierung Mehrdimensionaler Arrays}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  Wir wollen eine $N \times N$ Matrix linear im Speicher ablegen, wie verfahren wir?
\end{block}
\begin{lstlisting}
int N = 42;
double *A = malloc( N*N*sizeof(double) ); // 42^2 doubles
\end{lstlisting}
Der Index \texttt{i} für den Zugriff auf $A_{zs}$, ergibt sich aus der Formel:
\begin{equation*}
  i = s + N \cdot z
\end{equation*}
Für ein Objekt mit $3$ Indizes, $T_{i_0 i_1 i_2}$ der Größe $N_0 \times N_1 \times N_2$, ergibt sich:
\begin{align*}
  i = & i_2 + N_2 \cdot ( i_1 + ( N_1 \cdot i_0 ) ) \\
    = & i_2 + N_2 \cdot i_1 + N_2 \cdot N_1 \cdot i_0 \, ,
\end{align*}
wobei $i_0 \in [ 0, N_0-1 ], i_1 \in [ 0, N_1-1 ], i_2 \in [ 0, N_2-1 ] \Rightarrow i \in [ 0, N_0 \cdot N_1 \cdot N_2 - 1 ]$
\begin{block}{}
  Für unsere Matrix $A$ haben wir also:
\end{block}
\begin{lstlisting}
  A[ 1 + N*2 ] // A_{21}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Dynamische Mehrdimensionale Arrays}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  Wir wollen eine $N_0 \times N_1$ Matrix erstellen, aber nicht als statisches Array. Wir wollen es uns aber auch erlauben, darauf mit \texttt{[][]} zuzugreifen. Wie gehen wir vor?
\end{block}
\begin{lstlisting}
unsigned int N_0 = 27;
unsigned int N_1 = 13;
// Speicher fuer N_0*N_1 double-Werte
double *matrix_mem = malloc( N_0*N_1*sizeof(double) );
// Speicher fuer N_0 double-Zeiger
double **Matrix = malloc( N_0*sizeof(double*) );
for( unsigned int z = 0; z < N_0; z++ ){
  Matrix[z] = matrix_mem + N_1*z;
  // oder auch
  // Matrix[z] = &(matrix_mem[N_1*z]);
}
Matrix[2][1] = 2.2;
\end{lstlisting}
$\Rightarrow$ (\verb|lin_multidim_array.c|) und (\verb|dyn_multidim_array.c|)
\end{frame}

\stepcounter{lecturecounter}

\begin{frame}[fragile]{Fragen zu Vorlesung 5?}
  \begin{itemize}
    \item{Zeigerarithmetik}
    \vspace{0.2cm}
    \item{Dynamische Speicherverwaltung}
    \vspace{0.2cm}
    \item{Mehrdimensionale Arrays}
    \vspace{0.2cm}
    \item{Dynamische mehrdimensionale Arrays}
  \end{itemize}
\end{frame}

\begin{frame}{Visualisierung: Dynamischer Matrixspeicher}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  Freitag: Vorschlag für alternative Visualisierung der Matrixdatenstruktur aus Vorlesung 5.
\end{block}
\includegraphics[width=0.9\textwidth,page=6,trim=0 4cm 0 2cm,clip=true]{graphics/c_kurs_tafel}
\begin{block}{}
  Vorsicht: Spaltendimension nicht automatisch beschränkt! \\
  $\Rightarrow$ \texttt{M[0][3] == M[1][0]}
\end{block}
\end{frame}

\begin{frame}[fragile]{Vervollständigung: Speichermanagement}{Vorlesung \arabic{lecturecounter}}
\begin{lstlisting}
void* memmove(void *dest, void *src, unsigned int n);
\end{lstlisting}
  \begin{block}{}
    Mit \texttt{memmove} werden \texttt{n} Bytes von \texttt{src} nach \texttt{dest} kopiert.
  \end{block}

\begin{lstlisting}
void*  memset(void *dest, int b, unsigned int n);
\end{lstlisting}
  \begin{block}{}
    Mit \texttt{memset} werden \texttt{n} Bytes ab Speicherstelle \verb|dest| auf den Bytewert \verb|b| gesetzt. Oft hat man \verb|b=0|.
  \end{block}
  $\Rightarrow$ (\verb|test_memmove_memset.c|)
\end{frame}

\begin{frame}[fragile]{Vervollständigung: Speichermanagement}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  Einen allokierten Speicherbereich der Größe \verb|n_old|, kann man nachträglich mit \verb|realloc| vergrößern oder verkleinern.
\end{block}
\begin{lstlisting}
void* realloc(void *ptr, unsigned int n_new);
\end{lstlisting}
\begin{itemize}
  \item{Der Rückgabewert und \verb|ptr| müssen nicht übereinstimmen!}
  \begin{itemize}
    \item{Schlägt \verb|realloc| fehl, ist der Rückgabewert \verb|NULL|, \verb|ptr| bleibt aber weiterhin allokiert.}
    \item{Wenn nach \verb|ptr+n_old| kein zusammenhängender Speicherberich der Größe \verb|n_new-n_old| verfügbar ist, wird ein neuer Speicherbereich der Größe \verb|n_old| allokiert, die Daten aus \verb|ptr| werden dorthin kopiert, \verb|ptr| freigegeben und ein Zeiger auf den neuen Speicherbereich zurückgegeben.}
  \end{itemize}
  \item{Ist \verb|n_new < n_old|, bleibt der Anfang von \verb|ptr| bis \verb|n_new| unverändert.}
\end{itemize}
\begin{lstlisting}
dt* temp = realloc( ptr, n_new );
if( temp != NULL ){ ptr = temp; }
// ptr verwenden
\end{lstlisting}
  
  $\Rightarrow$ (\verb|test_realloc.c|)
\end{frame}

\begin{frame}[fragile]{Eingabe und Ausgabe: \texttt{fopen}}{Vorlesung \arabic{lecturecounter}}
  \begin{block}{}
    C bietet eine Zahl von Funktionen zur Eingabe und Ausgabe, zunächst muss eine Datei jedoch immer geöffnet werden.
  \end{block}
\begin{lstlisting}
FILE* fopen(char *pfad, char *modus);   
\end{lstlisting}
\begin{block}{}
Modus ist ein \texttt{string}, anhand dessen entschieden wird, welche Dateioperationen durchgeführt werden.
\end{block}
\centering
\small
  \begin{tabular}{lr}
    \hline
    \texttt{modus}  & Bedeutung                           \\\hline
    \verb|"w"|      & (erstellen) (über-)schreiben        \\
    \verb|"r"|      & lesen                               \\
    \verb|"a"|      & erstellen oder hinzufügen           \\
    \verb|"w+"|     & erstellen oder hinzufügen + lesen   \\
    \verb|"r+"|     & lesen + schreiben (nicht erstellen) \\
    \verb|"a+"|     & wie \verb|"a"| + lesen              \\
    \hline
  \end{tabular}
\begin{block}{}
  Der Rückgabewert von \texttt{fopen} ist bei Erfolg ein \emph{Dateizeiger} auf einen \emph{Stream}, ansonsten ein Nullpointer. $\rightarrow$ auf \texttt{NULL} prüfen!
\end{block}

\end{frame}

\begin{frame}[fragile]{Eingabe und Ausgabe: \texttt{fopen}}{Vorlesung \arabic{lecturecounter}}
\begin{lstlisting}
FILE* ausgabedatei = fopen("/pfad/zu/den/daten/daten.txt", "r");
if( ausgabedetail != NULL ){
  // Datei bereit, ausgelesen zu werden
} else {
  // Datei existiert nicht oder sonstiger Fehler!
}
\end{lstlisting}
\vspace{-0.2cm}
\begin{block}{}
  \footnotesize
  \verb|pfad| kann hierbei absolut sein:
  \begin{itemize}
    \item{UNIX:    \verb|/home/user/pfad/zu/den/daten/daten.txt|}
    \item{Windows: \verb|C:\Eigene Dateien\Dokumente\daten.txt|}
  \end{itemize}
  oder relativ zum Verzeichnis, in dem das Programm ausgeführt wurde:
  \begin{itemize}
    \item{UNIX:    \verb|pfad/zu/den/daten/daten.txt|}
    \item{Window:  \verb|pfad\zu\den\daten\daten.txt|}
  \end{itemize}
  Im zweiten Fall wird der Pfad des momentanen Verzeichnisses vorgestellt.
\end{block}
\begin{block}{}
  \footnotesize
  Erst, nachdem die Datei geschlossen wurde, kann sichergestelllt sein, dass auch alles geschrieben wurde. $\rightarrow$ \texttt{fclose}
\end{block}
$\Rightarrow$ (\verb|test_fopen_fclose.c|)
\end{frame}

\begin{frame}[fragile]{Mit \texttt{fprintf} Textdateien schreiben}{Vorlesung \arabic{lecturecounter}}
\begin{lstlisting}
int fprintf(FILE *fp, char *format, ...);
\end{lstlisting}
\begin{block}{}
  \texttt{fprintf} funktioniert wie \texttt{printf}, mit dem Unterschied, dass ein Dateizeiger übergeben werden muss. Um genau zu steuern, wie die Ausgabe auszusehen hat können die Platzhalter durch Parameter gesteuert werden.
\end{block}
\begin{lstlisting}
  % + - 0 @BREITE@ . @PRAEZISION@ ll/l/h [d,u,s,c,p,g,e,f]  
\end{lstlisting}
\begin{columns}
\column{0.3\textwidth}
\texttt{format}, \texttt{argument} 
\begin{lstlisting}
%.2f, 2.3453
%5d, 32
%05d, 32
%05d, 999932
%+05d, 32
%-5d, 32, 1
%8.3f, 42.3453
\end{lstlisting}
\column{0.69\textwidth}
Ausgabe
\begin{lstlisting}
2.35
   32
00032
999932
+0032
32   1
  42.345
\end{lstlisting}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Formatierte Textdateien lesen mit \texttt{fscanf}}
\begin{block}{}
  \texttt{(s)scanf} hatten wir kurz erwähnt, als es um Kommandozeilenargumente und das Einlesen von Daten aus der Konsole ging. \verb|fscanf| ist eine ähnliche Funktion für Dateistreams.
\end{block}
\begin{lstlisting}
int fscanf(FILE *stream, const char *format, ...);
\end{lstlisting}
$\Rightarrow$ (\verb|test_fscanf.c|)
\end{frame}

\begin{frame}[fragile]{Mit \texttt{fwrite / fread} Binärdateien schreiben und lesen}{Vorlesung \arabic{lecturecounter}}
\begin{block}{}
  Datenstrukturen in C können direkt blockweise ausgeschrieben und eingelesen werden, solange man einen enstprechenden Speicherbereich allokiert hat.
\end{block}
\begin{lstlisting}
unsigned int fwrite(void* data, unsigned int blockgroesse, unsigned int anzahl, FILE* fp);
unsigned int fread(void* data, unsigned int blockgroesse, unsigned int anzahl, FILE* fp);
\end{lstlisting}
\begin{block}{}
  Um zu prüfen, ob das Ende der Datei erreicht wurde oder ein Fehler aufgetreten ist, werden \texttt{feof} und \texttt{ferror} genutzt.
\end{block}
\begin{lstlisting}
int feof(FILE* fp);
int ferror(FILE* fp);
\end{lstlisting}
$\Rightarrow$ (\verb|test_fwrite_fread.c|) 
\end{frame}

\begin{frame}[fragile]{Den Dateicursor bewegen mit \texttt{fseek}}
\begin{block}{}
  Jede Lese- und Schreiboperation bewegt den Dateicursor des Streams. Um diesen Dateicursor selbst zu bewegen, wird \verb|fseek| genutzt.
\end{block}
\begin{lstlisting}
int fseek(FILE *stream, long offset, int origin);
\end{lstlisting}
\includegraphics[width=\textwidth,page=5,trim=0 13cm 0 2cm,clip=true]{graphics/c_kurs_tafel}
\begin{block}{}
  Um herauszufinden, wo der Dateicursor sich gerade befindent, kann man \verb|ftell| benutzen.
\end{block}
\begin{lstlisting}
long ftell(FILE *stream);
\end{lstlisting}
$\Rightarrow$ (\verb|test_fseek.c|)
\end{frame}



\end{document}